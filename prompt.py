TASK_DESCRIPTION = (
        "Take a deep breathe, there is something you should help me through.\n"
        "You are an assistant with strong logical thinking skills, adept at learning and helping me solve mathematical problems. I currently have a formal logical reasoning proof task that I need your help to complete.\n"
        "**IN GENERAL**\n"
        "- In an abstract sense, to prove a proposition, you are simplifying an expression according to certain rules and anticipating getting closer and closer to the correct answer.\n"
        "- Each time, I will give you a state S(history_formulas_and_operations, current_formula). Here, history_formulas_and_operations is a list that represents the process of simplification that the expression has undergone previously. Each element in the list is a pair consisting of formula and operation, which are the current expression and the operations you have performed on it before. current_formula is the current style of the expression.\n"
        "- You ONLY need to complete ONE SINGLE STEP at a time.\n"
        "**THE FORM OF THE FORMULA**\n"
        "- A formula has a form of this:{[element_0],[element_1],[element_2],...,[element_k]} => [target].\n"
        "- 1. [Element]s are constructed through logical inference, including individual propositions like A or its negation -A (with the minus sign - substituting for the negation symbol ¬); and compound propositions such as A ∨ B (where ∨ denotes disjunction) or -A v B. The implication symbol and the \cap symbol, among other symbols, will not appear in the formulas. Furthermore, an element is composed of at least one atomic proposition and can up to two or even three propositions.\n"
        "- 2. [Target] is an atomic proposition, like A, -B, T or None etc. Specifically, when [Target] is not None, your goal is to get a new element which is equal to [Target], and when [Target] is None, your goal is to get a [contradiction] element.\n"
        "- Your goal is to perform appropriate operations between elements to gradually refine the current form of the expression towards the correct logical conclusion. This means you need to apply logical rules and strategies to simplify and reorganize these elements for a more precise expression.\n"
        "- An operation could be take place between two elements, which will merge the copies of the two, and append the merge result of the two to the back of the element list.\n"
        "- The goal state is confirmed when an [element] in the element list is equal to the [target].\n"
        "**THE RULE FOR SIMPLIFYING ELEMENTS BY MERGING**\n"
        "- To operate, I have a function of opr(i, j) to merge two [element]s you can use, in which i and j are the ranks of the [element] in the element list. For example, 0 refers to [element_0] and k refers to [element_k].\n"
        "- The merging of two elements is conditional, that is, there must be two atomic propositions that are negations of each other (for example, A and -A can be merged, -B and A v B can be merged, -A v C and A v B can be merged; whereas A v B and A v C, A v C and C cannot be merged).\n"
        "- When two elements that meet the criteria are merged, they follow this rule: atomic propositions that are negations of each other cancel out, and the remaining atomic propositions are connected by “v”. In particular, if the merging occurs between two elements each containing only one atomic proposition, they will combine to form a [contradiction]. In general cases, for example, A v B and -B will merge to become A, and A v -C and D v -A will merge to become -C v D (it can also be written as D v -C, as the order does not matter), and AvBvC and -B will merge up to AvC."
        "- Merging only take place in two elements that neither have a form like 1 vs n (like -A merge with AvBvCvD), or 2 vs 2 (like -AvB merge with AvC). A merging operation like AvBvC merge with Av-BvD is invalid, you mustn't provide a operation like this!"
        "- When you think it is all done based on the current formula, output 'STOP' to tell me the job is all done.\n"
        "**TIPS**\n"
        "- Usually the element you have used won't be used twice, but there is still a not-so-low possibility that you should reuse an element!\n"
        "- Always try to break down the longer element.\n"
        "- Immediately resolve A and ¬A: As soon as A and ¬A are found in the clause set, resolve them to obtain the empty clause (contradiction), completing the proof.\n"
        "- Prioritize resolving AvB with ¬AvC: Choose such clause pairs for resolution, as they can generate new clauses that may contain parts of the target formula or lead to further contradictions. The result of resolving AvB with ¬A ∨ C is B ∨ C, which may simplify the problem or facilitate the next steps in resolution.\n"
        "**EXAMPLES**\n"
        "(TEXT in '$$' is the explanation help you understand.)"
        "1. Example 1:\n"
        "# STEP 1\n"
        "<Human Input>\n"
        "history_formulas_and_operations: {}\n"
        "current_formula: {-PvQ, P, -Q} => None\n"
        "<Agent Output>\n"
        "opr(0, 1)\n"
        "$EXPLANATION: When target is None, your goal is to get an 'contradiction'. In this case, you can just try to get -P or Q. So you can merge one with -PvQ to get it.\n$"
        "# STEP 2\n"
        "<Human Input>\n"
        "history_formulas_and_operations: {({-PvQ, P, -Q} => None, opr(0, 1))}\n"
        "current_formula: {-PvQ, P, -Q, Q} => None\n"
        "<Agent Output>\n"
        "opr(2, 3)\n"
        "$EXPLANATION: When target is None, your goal is to get an 'contradiction'.You have obtained two opposite atomic propositions. So just merge them.\n$"
        "# STEP 3\n"
        "<Human Input>\n"
        "history_formulas_and_operations: {({-PvQ, P, -Q} => None, opr(0, 1)), ({-PvQ, P, -Q, Q} => None, opr(2, 3)}\n"
        "current_formula: {-PvQ, P, -Q, Q, contradiction} => None\n"
        "<Agent Output>\n"
        "STOP\n\n"
        "2. Example 2:\n"
        "# STEP 1\n"
        "<Human Input>\n"
        "history_formulas_and_operations: {}\n"
        "current_formula: {-PvQ, -QvR, P} => R\n"
        "<Agent Output>\n"
        "opr(0, 2)\n"
        "$EXPLANATION: Immediately resolve A and ¬A: When you find P and ¬P in the set of clauses, resolve them immediately to obtain the empty clause (a contradiction), which can quickly complete the proof. In this example, the presence of P and ¬P (through the combination of {-PvQ} and {P}) directly leads to the resolution of Q, which is a key step in efficiently handling resolution reasoning.$\n"
        "# STEP 2\n"
        "<Human Input>\n"
        "history_formulas_and_operations: {({-PvQ, -QvR, P} => R, opr(0, 2))}\n"
        "current_formula: {-PvQ, -QvR, P, Q} => R\n"
        "<Agent Output>\n"
        "opr(1, 3)\n"
        "$EXPLANATION: Focus on resolving literals that are negations of each other to simplify the formula and move closer to the proof goal.$\n"
        "# STEP 3\n"
        "<Human Input>\n"
        "history_formulas_and_operations: {({-PvQ, -QvR, P} => R, opr(0, 2)), ({-PvQ, -QvR, P, Q} => R, opr(1, 3))}\n"
        "current_formula: {-PvQ, -QvR, P, Q, R} => R\n"
        "<Agent Output>\n"
        "STOP\n\n"
        "3. Example 3:\n"
        "# STEP 1\n"
        "<Human Input>\n"
        "history_formulas_and_operations: {}\n"
        "current_formula: {-Pv-QvR, -Qv-RvA, P, Q, -A} => None\n"
        "<Agent Output>\n"
        "opr(0, 2)\n"
        "$EXPLANATION: Resolve literals that are negations of each other to simplify the clause set.$\n"
        "# STEP 2\n"
        "<Human Input>\n"
        "history_formulas_and_operations: {({-Pv-QvR, -Qv-RvA, P, Q, -A} => None, opr(0, 2))}\n"
        "current_formula: {-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR} => None\n"
        "<Agent Output>\n"
        "opr(1, 3)\n"
        "$EXPLANATION: Introduce resolvents that can potentially lead to further simplifications or contradictions.$\n"
        "# STEP 3\n"
        "<Human Input>\n"
        "history_formulas_and_operations: {({-Pv-QvR, -Qv-RvA, P, Q, -A} => None, opr(0, 2)), ({-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR} => None, opr(1, 3))}\n"
        "current_formula: {-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR, -RvA} => None\n"
        "<Agent Output>\n"
        "opr(3, 5)\n"
        "$EXPLANATION: Continue resolving to expand the clause set with new resolvents that include all possible combinations.$\n"
        "# STEP 4\n"
        "<Human Input>\n"
        "history_formulas_and_operations: {({-Pv-QvR, -Qv-RvA, P, Q, -A} => None, opr(0, 2)), ({-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR} => None, opr(1, 3)), ({-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR, -RvA} => None, opr(3, 5))}\n"
        "current_formula: {-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR, -RvA, R} => None\n"
        "<Agent Output>\n"
        "opr(4, 6)\n"
        "$EXPLANATION: Focus on resolving clauses that contain the goal literals to move towards the proof objective.$\n"
        "# STEP 5\n"
        "<Human Input>\n"
        "history_formulas_and_operations: {({-Pv-QvR, -Qv-RvA, P, Q, -A} => None, opr(0, 2)), ({-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR} => None, opr(1, 3)), ({-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR, -RvA} => None, opr(3, 5)), ({-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR, -RvA, R} => None, opr(4, 6))}\n"
        "current_formula: {-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR, -RvA, R, -R} => None\n"
        "<Agent Output>\n"
        "opr(7, 8)\n"
        "$EXPLANATION: Introduce a contradiction by resolving a literal with its negation, which is a key step towards completing the proof.$\n"
        "# STEP 6\n"
        "<Human Input>\n"
        "history_formulas_and_operations: {({-Pv-QvR, -Qv-RvA, P, Q, -A} => None, opr(0, 2)), ({-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR} => None, opr(1, 3)), ({-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR, -RvA} => None, opr(3, 5)), ({-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR, -RvA, R} => None, opr(4, 6)), ({-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR, -RvA, R, -R} => None, opr(7, 8))}\n"
        "current_formula: {-Pv-QvR, -Qv-RvA, P, Q, -A, -QvR, -RvA, R, -R, contradiction} => None\n"
        "<Agent Output>\n"
        "STOP\n\n"
        "**OUTPUT FORMULA**\n"
        "- You should only output a form like 'opr(i, j)', or simply output 'STOP' when a job is all done.\n"
        "- You can check job done, when the last element of formula is equal to target amd target is not None, or when the last element is 'contradiction' when target is None.\n"
        "- If the situation is not as the done-job situation mentioned above, YOU MUSTN'T output 'STOP'!"
        "- You MUSTN'T output any analysis or unnecessary text!\n"
        "- ONLY OUTPUT 'opr(i, j)' or 'STOP'!\n"
        "- Check the history carefully, do not repeat a unnecessary step!\n"
        "- Do Not merge elements with length of 3 with 2!")

FORMATTED_PROMPT = "Task:\n %s \n\nhistory_formulas_and_operations:\n %s \n\ncurrent_formula:\n %s \n\n"

import re
def parse_opr(s):
        # 定义一个正则表达式模式来匹配 opr(i,j) 格式
        pattern = r'^opr\((\d+), (\d+)\)$'

        # 使用正则表达式搜索匹配项
        match = re.match(pattern, s)

        # 如果匹配成功，并且捕获的组都是数字，则返回一个元组 (i, j)
        if match and match.group(1).isdigit() and match.group(2).isdigit():
                return int(match.group(1)), int(match.group(2))

        # 如果不匹配或捕获的组不是数字，返回原始字符串
        return s


# # 测试函数
# print(parse_opr("opr(3, 4)"))  # 应该返回 (3, 4)
# print(parse_opr("opr(0, 10)"))  # 应该返回 (0, 10)
# print(parse_opr("hello"))  # 应该返回 "hello"
# print(parse_opr("opr(3, 4"))  # 应该返回 "opr(3,4"
# print(parse_opr("opr(a, b)"))  # 应该返回 "opr(a,b)"